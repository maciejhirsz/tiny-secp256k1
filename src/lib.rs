#![no_std]

mod big_num;
mod naf;
mod ec_point;
mod ec_point_g;
mod ecj_point;

pub use ec_point_g::ECPointG;

use big_num::BigNum;

pub fn is_valid_secret(bytes: &[u8]) -> bool {
    if bytes.len() != 32 {
        return false;
    }

    let num = BigNum::from(bytes);

    !num.is_overflow() && num != 0
}

pub fn create_public_key(g: &ECPointG, secret: &[u8]) -> Option<[u8; 65]> {
    let num = BigNum::from(secret);

    if num.is_overflow() || num == 0 {
        return None;
    }

    Some(g.mul(num).to_public_key())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn create_public_key() {
        let secret: &[u8] = &[
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x01,
        ];

        let expected: &[u8] = &[
            0x04,0x79,0xbe,0x66,0x7e,0xf9,0xdc,0xbb,0xac,0x55,0xa0,0x62,0x95,
            0xce,0x87,0x0b,0x07,0x02,0x9b,0xfc,0xdb,0x2d,0xce,0x28,0xd9,0x59,
            0xf2,0x81,0x5b,0x16,0xf8,0x17,0x98,0x48,0x3a,0xda,0x77,0x26,0xa3,
            0xc4,0x65,0x5d,0xa4,0xfb,0xfc,0x0e,0x11,0x08,0xa8,0xfd,0x17,0xb4,
            0x48,0xa6,0x85,0x54,0x19,0x9c,0x47,0xd0,0x8f,0xfb,0x10,0xd4,0xb8
        ];

        let g = ECPointG::new();

        let key = super::create_public_key(&g, secret).unwrap();

        assert_eq!(&key[..], expected);
    }
}
